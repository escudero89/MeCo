## Copyright (C) 2013 Marcos
## 
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with Octave; see the file COPYING.  If not, see
## <http://www.gnu.org/licenses/>.

## conduccionCalor_estacionario_no_homogeneo_1d

## Author: Marcos <marcos@marcos-Notebook>
## Created: 2013-09-06

function [ phi ] = conduccionCalor_estacionario_no_homogeneo_1d (cant_x, Lx, 
                             dirich_1=0, dirich_2=1, neumman_1=-1, neumman_2=-1, 
                             Q=@Q_default, k=@k_default, c=@c_default,
                             phi_amb=@phi_amb_default)

#    dx = Lx/cant_x;
#    x = 0:dx:Lx-dx;
    x=[0 0.05 0.15 0.35 0.5 0.75 1];
    

  ## SI DIRICHLET
    
    h1 = [];
    h2 = [];
    alpha = [];
  
    
    # Creamos vectores h1, h2 y alpha (que vincula h1 y h2).
    for( i = 2 : length(x) - 1 )
        h1 = [h1, x(i - 1)-x(i )];                
        h2 = [h2, x(i + 1)-x(i)];
        alpha = [alpha,  abs( h2(i-1)/h1(i-1) ) ];
    endfor

    # Armamos tri-diagonal de la matriz. 
    diagonal = [];

    
    for( i=2:length(x)-1 )
        diagonal(i-1, :) = [ (2 * k( x(i) ) ) / ( h1(i-1)^2 * ( 1 + alpha(i-1) ) ) ,
                        (-2 * k( x(i) ) / ( h1(i-1)^2) )  + c( x(i) ) ,
                        (2 * k( x(i) ) /  ( h1(i-1)^2 * alpha(i-1) * ( 1 + alpha(i-1) ) ) ) 
                        ];                
    endfor

    #Agregamos condiciones de contorno Dirichlet en la diagonal
    diagonal = [[0 1 0]; diagonal ];
    diagonal = [diagonal; [0 1 0] ];

    # Armamos Matriz, convirtiendo el vector tridiagonal en Matriz.
    K  = diag( diagonal(:,2) );                #(diagonal prinicpal)
    K += diag( diagonal(2:end, 1), -1);        #(diagonal inferior)
    K += diag( diagonal(1:end-1, 3), +1);      #(diagonal superior)
    
    K
    pause

    # Armamos termino independiente f
    f(1) = dirich_1;    
    for(i = 2:length(x) - 1)    
        f(i) = -Q( x(i) ) + c( x(i) ) * phi_amb( x(i) );
    endfor
    f( length(x) ) = dirich_2;
    
    f
    pause
    # Resolvemos sistema.
    phi = K\f';


  ## PLOTEO
    plot(x,phi);
    
    
endfunction



function [ Q_x ] = Q_default(x)
    Q_x = - 10 * x * (x+1);
endfunction

function [ k_x ] = k_default(x)
    k_x = 1;
endfunction

function [ c_x ] = c_default(x)
    c_x = 1;
endfunction

function [ phi_amb_x ] = phi_amb_default(x)
    phi_amb_x = 0;
endfunction
